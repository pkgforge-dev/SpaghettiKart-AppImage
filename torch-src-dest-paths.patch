From 087f1cc1ce28a566b292494de09c834b6492a027 Mon Sep 17 00:00:00 2001
From: AltoXorg <56553686+Alto1772@users.noreply.github.com>
Date: Wed, 23 Jul 2025 23:37:30 +0800
Subject: [PATCH 1/2] Add configurable src and dest paths

---
 src/Companion.cpp | 28 ++++++++++++++++------------
 src/Companion.h   | 16 ++++++++++++++--
 src/main.cpp      | 21 +++++++++++++--------
 3 files changed, 43 insertions(+), 22 deletions(-)

diff --git a/src/Companion.cpp b/src/Companion.cpp
index 2df11096..762ebd35 100644
--- a/src/Companion.cpp
+++ b/src/Companion.cpp
@@ -349,13 +349,13 @@ void Companion::ParseCurrentFileConfig(YAML::Node node) {
             for(size_t i = 0; i < externalFiles.size(); i++) {
                 auto externalFile = externalFiles[i];
                 if (externalFile.size() == 0) {
-                    this->gCurrentExternalFiles.push_back(externalFile.as<std::string>());
+                    this->gCurrentExternalFiles.push_back(this->gSourceDirectory / externalFile.as<std::string>());
                 } else {
                     SPDLOG_INFO("External File size {}", externalFile.size());
                     throw std::runtime_error("Incorrect yaml syntax for external files.\n\nThe yaml expects:\n:config:\n  external_files:\n  - <external_files>\n\ne.g.:\nexternal_files:\n  - actors/actor1.yaml");
                 }
 
-                auto externalFileName = externalFile.as<std::string>();
+                std::string externalFileName = this->gSourceDirectory / externalFile.as<std::string>();
                 if (std::filesystem::relative(externalFileName, this->gAssetPath).string().starts_with("../")) {
                     throw std::runtime_error("External File " + externalFileName + " Not In Asset Directory " + this->gAssetPath);
                 } else if (std::filesystem::relative(externalFileName, this->gAssetPath).string() == "") {
@@ -475,7 +475,7 @@ void Companion::ParseCurrentFileConfig(YAML::Node node) {
 }
 
 void Companion::ParseHash() {
-    const std::string out = "torch.hash.yml";
+    const std::string out = this->gDestinationPath / "torch.hash.yml";
 
     if(fs::exists(out)) {
         this->gHashNode = YAML::LoadFile(out);
@@ -983,13 +983,15 @@ void Companion::ProcessFile(YAML::Node root) {
 
 void Companion::Process() {
 
-    if(!fs::exists("config.yml")) {
+    auto configPath = this->gSourceDirectory / "config.yml";
+
+    if(!fs::exists(configPath)) {
         SPDLOG_ERROR("No config file found");
         return;
     }
 
     auto start = duration_cast<milliseconds>(system_clock::now().time_since_epoch());
-    YAML::Node config = YAML::LoadFile("config.yml");
+    YAML::Node config = YAML::LoadFile(configPath);
 
     bool isDirectoryMode = config["mode"] && config["mode"].as<std::string>() == "directory";
 
@@ -1067,13 +1069,14 @@ void Companion::Process() {
             this->gConfig.segment.global[i + 1] = segments[i];
         }
     }
-    this->gAssetPath = rom["path"].as<std::string>();
+    this->gAssetPath = this->gSourceDirectory / rom["path"].as<std::string>();
     auto opath = cfg["output"];
     auto gbi = cfg["gbi"];
     auto gbi_floats = cfg["gbi_floats"];
     auto modding_path = opath && opath["modding"] ? opath["modding"].as<std::string>() : "modding";
+    auto output_path = this->gDestinationPath;
 
-    this->gConfig.moddingPath = modding_path;
+    this->gConfig.moddingPath = this->gSourceDirectory / modding_path;
     switch (this->gConfig.exporterType) {
         case ExportType::Binary: {
             std::string extension = "";
@@ -1087,23 +1090,24 @@ void Companion::Process() {
                 default:
                     throw std::runtime_error("Invalid archive type for export type Binary");
             }
-            this->gConfig.outputPath = opath && opath["binary"] ? opath["binary"].as<std::string>() : ("generic" + extension);
+            output_path /= opath && opath["binary"] ? opath["binary"].as<std::string>() : ("generic" + extension);
             break;
         }
         case ExportType::Header: {
-            this->gConfig.outputPath = opath && opath["headers"] ? opath["headers"].as<std::string>() : "headers";
+            output_path /= opath && opath["headers"] ? opath["headers"].as<std::string>() : "headers";
             break;
         }
         case ExportType::Code: {
-            this->gConfig.outputPath = opath && opath["code"] ? opath["code"].as<std::string>() : "code";
+            output_path /= opath && opath["code"] ? opath["code"].as<std::string>() : "code";
             break;
         }
         case ExportType::XML:
         case ExportType::Modding: {
-            this->gConfig.outputPath = modding_path;
+            output_path /= modding_path;
             break;
         }
     }
+    this->gConfig.outputPath = output_path;
 
     if(gbi) {
         auto key = gbi.as<std::string>();
@@ -1273,7 +1277,7 @@ void Companion::Process() {
     }
 
     // Write entries hash
-    std::ofstream file("torch.hash.yml", std::ios::binary);
+    std::ofstream file(this->gDestinationPath / "torch.hash.yml", std::ios::binary);
     file << this->gHashNode;
     file.close();
 
diff --git a/src/Companion.h b/src/Companion.h
index ad183230..bff5a72f 100644
--- a/src/Companion.h
+++ b/src/Companion.h
@@ -112,7 +112,9 @@ class Companion {
 public:
     static Companion* Instance;
 
-    explicit Companion(std::filesystem::path rom, const ArchiveType otr, const bool debug, const bool modding = false) : gCartridge(nullptr) {
+    explicit Companion(std::filesystem::path rom, const ArchiveType otr, const bool debug, const bool modding = false,
+                       const std::string& srcDir = "", const std::string& destPath = "") : gCartridge(nullptr),
+                       gSourceDirectory(srcDir), gDestinationPath(destPath) {
         this->gRomPath = rom;
         this->gConfig.otrMode = otr;
         this->gConfig.debug = debug;
@@ -120,7 +122,9 @@ class Companion {
         this->gConfig.textureDefines = false;
     }
 
-    explicit Companion(std::vector<uint8_t> rom, const ArchiveType otr, const bool debug, const bool modding = false) : gCartridge(nullptr) {
+    explicit Companion(std::vector<uint8_t> rom, const ArchiveType otr, const bool debug, const bool modding = false,
+                       const std::string& srcDir = "", const std::string& destPath = "") : gCartridge(nullptr),
+                       gSourceDirectory(srcDir), gDestinationPath(destPath) {
         this->gRomData = rom;
         this->gConfig.otrMode = otr;
         this->gConfig.debug = debug;
@@ -128,6 +132,12 @@ class Companion {
         this->gConfig.textureDefines = false;
     }
 
+    explicit Companion(std::filesystem::path rom, const ArchiveType otr, const bool debug, const std::string& srcDir = "", const std::string& destPath = "") :
+                       Companion(rom, otr, debug, false, srcDir, destPath) {}
+
+    explicit Companion(std::vector<uint8_t> rom, const ArchiveType otr, const bool debug, const std::string& srcDir = "", const std::string& destPath = "") :
+                       Companion(rom, otr, debug, false, srcDir, destPath) {}
+
     void Init(ExportType type);
 
     bool NodeHasChanges(const std::string& string);
@@ -179,6 +189,8 @@ class Companion {
 private:
     TorchConfig gConfig;
     YAML::Node gModdingConfig;
+    fs::path gSourceDirectory;
+    fs::path gDestinationPath;
     fs::path gCurrentDirectory;
     std::string gCurrentHash;
     std::string gAssetPath;
diff --git a/src/main.cpp b/src/main.cpp
index 23b80ffe..afb3536c 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -20,9 +20,14 @@ int main(int argc, char *argv[]) {
     bool otrModeSelected = false;
     bool xmlMode = false;
     bool debug = false;
+    std::string srcdir;
+    std::string destdir
 
     app.require_subcommand();
 
+    app.add_option("-s", "--srcdir", srcdir, "Set source directory to locate config.yml, asset metadata, and modding files for importing");
+    app.add_option("-d", "--destdir", destdir, "Set destination directory for exporting and generating binaries and source code");
+
     /* Generate an OTR */
     const auto otr = app.add_subcommand("otr", "OTR - Generates an otr\n");
 
@@ -30,7 +35,7 @@ int main(int argc, char *argv[]) {
     otr->add_flag("-v,--verbose", debug, "Verbose Debug Mode");
 
     otr->parse_complete_callback([&] {
-        const auto instance = Companion::Instance = new Companion(filename, ArchiveType::OTR, debug);
+        const auto instance = Companion::Instance = new Companion(filename, ArchiveType::OTR, debug, srcdir, destdir);
         instance->Init(ExportType::Binary);
     });
 
@@ -41,7 +46,7 @@ int main(int argc, char *argv[]) {
     o2r->add_flag("-v,--verbose", debug, "Verbose Debug Mode");
 
     o2r->parse_complete_callback([&] {
-        const auto instance = Companion::Instance = new Companion(filename, ArchiveType::O2R, debug);
+        const auto instance = Companion::Instance = new Companion(filename, ArchiveType::O2R, debug, srcdir, destdir);
         instance->Init(ExportType::Binary);
     });
 
@@ -52,7 +57,7 @@ int main(int argc, char *argv[]) {
     code->add_flag("-v,--verbose", debug, "Verbose Debug Mode; adds offsets to C code");
 
     code->parse_complete_callback([&]() {
-        const auto instance = Companion::Instance = new Companion(filename, ArchiveType::None, debug);
+        const auto instance = Companion::Instance = new Companion(filename, ArchiveType::None, debug, srcdir, destdir);
         instance->Init(ExportType::Code);
     });
 
@@ -62,7 +67,7 @@ int main(int argc, char *argv[]) {
     binary->add_option("<baserom.z64>", filename, "")->required()->check(CLI::ExistingFile);
 
     binary->parse_complete_callback([&] {
-        const auto instance = Companion::Instance = new Companion(filename, ArchiveType::None, debug);
+        const auto instance = Companion::Instance = new Companion(filename, ArchiveType::None, debug, srcdir, destdir);
         instance->Init(ExportType::Binary);
     });
 
@@ -80,7 +85,7 @@ int main(int argc, char *argv[]) {
             otrMode = ArchiveType::None;
         }
 
-        const auto instance = Companion::Instance = new Companion(filename, otrMode, debug);
+        const auto instance = Companion::Instance = new Companion(filename, otrMode, debug, srcdir, destdir);
         instance->Init(ExportType::Header);
     });
 
@@ -128,7 +133,7 @@ int main(int argc, char *argv[]) {
             otrMode = ArchiveType::None;
         }
 
-        const auto instance = Companion::Instance = new Companion(filename, otrMode, debug, true);
+        const auto instance = Companion::Instance = new Companion(filename, otrMode, debug, true, srcdir, destdir);
         if (mode == "code") {
             instance->Init(ExportType::Code);
         } else if (mode == "otr" || mode == "o2r") {
@@ -144,7 +149,7 @@ int main(int argc, char *argv[]) {
     modding_export->add_option("<baserom.z64>", filename, "")->required()->check(CLI::ExistingFile);
 
     modding_export->parse_complete_callback([&] {
-        const auto instance = Companion::Instance = new Companion(filename, ArchiveType::None, debug);
+        const auto instance = Companion::Instance = new Companion(filename, ArchiveType::None, debug, srcdir, destdir);
         if (xmlMode) {
             instance->Init(ExportType::XML);
         } else {
@@ -166,4 +171,4 @@ int main(int argc, char *argv[]) {
 
     return 0;
 }
-#endif
\ No newline at end of file
+#endif

From 42af277f800bc05f02d41bc2972e3e7c307deb50 Mon Sep 17 00:00:00 2001
From: AltoXorg <56553686+Alto1772@users.noreply.github.com>
Date: Thu, 24 Jul 2025 12:58:05 +0800
Subject: [PATCH 2/2] Expand the src dest feature to every mode

---
 src/Companion.cpp                          | 38 +++++++++++++++-------
 src/Companion.h                            |  9 +++--
 src/factories/CompressedTextureFactory.cpp |  4 +--
 src/factories/TextureFactory.cpp           |  4 +--
 src/main.cpp                               | 20 +++++++++---
 5 files changed, 51 insertions(+), 24 deletions(-)

diff --git a/src/Companion.cpp b/src/Companion.cpp
index 762ebd35..61cdf4c1 100644
--- a/src/Companion.cpp
+++ b/src/Companion.cpp
@@ -475,7 +475,7 @@ void Companion::ParseCurrentFileConfig(YAML::Node node) {
 }
 
 void Companion::ParseHash() {
-    const std::string out = this->gDestinationPath / "torch.hash.yml";
+    const std::string out = this->gDestinationDirectory / "torch.hash.yml";
 
     if(fs::exists(out)) {
         this->gHashNode = YAML::LoadFile(out);
@@ -506,9 +506,10 @@ bool Companion::NodeHasChanges(const std::string& path) {
     const std::vector<uint8_t> data = std::vector<uint8_t>(std::istreambuf_iterator( yaml ), {});
     this->gCurrentHash = CalculateHash(data);
     bool needsInit = true;
+    auto srcRelativePath = RelativePathToSrcDir(path);
 
-    if(this->gHashNode[path]) {
-        auto entry = GetSafeNode<YAML::Node>(this->gHashNode, path);
+    if(this->gHashNode[srcRelativePath]) {
+        auto entry = GetSafeNode<YAML::Node>(this->gHashNode, srcRelativePath);
         const auto hash = GetSafeNode<std::string>(entry, "hash", "no-hash");
         auto modes = GetSafeNode<YAML::Node>(entry, "extracted");
         auto extracted = GetSafeNode<bool>(modes, ExportTypeToString(this->gConfig.exporterType));
@@ -516,18 +517,18 @@ bool Companion::NodeHasChanges(const std::string& path) {
         if(hash == this->gCurrentHash) {
             needsInit = false;
             if(extracted) {
-                SPDLOG_INFO("Skipping {} as it has not changed", path);
+                SPDLOG_INFO("Skipping {} as it has not changed", srcRelativePath);
                 return false;
             }
         }
     }
 
     if(needsInit) {
-        this->gHashNode[path] = YAML::Node();
-        this->gHashNode[path]["hash"] = this->gCurrentHash;
-        this->gHashNode[path]["extracted"] = YAML::Node();
+        this->gHashNode[srcRelativePath] = YAML::Node();
+        this->gHashNode[srcRelativePath]["hash"] = this->gCurrentHash;
+        this->gHashNode[srcRelativePath]["extracted"] = YAML::Node();
         for(size_t m = 0; m <= static_cast<size_t>(ExportType::Modding); m++) {
-            this->gHashNode[path]["extracted"][ExportTypeToString(static_cast<ExportType>(m))] = false;
+            this->gHashNode[srcRelativePath]["extracted"][ExportTypeToString(static_cast<ExportType>(m))] = false;
         }
     }
 
@@ -977,7 +978,7 @@ void Companion::ProcessFile(YAML::Node root) {
     }
 
     if(this->gConfig.exporterType != ExportType::Binary) {
-        this->gHashNode[this->gCurrentFile]["extracted"][ExportTypeToString(this->gConfig.exporterType)] = true;
+        this->gHashNode[RelativePathToSrcDir(this->gCurrentFile)]["extracted"][ExportTypeToString(this->gConfig.exporterType)] = true;
     }
 }
 
@@ -1074,9 +1075,13 @@ void Companion::Process() {
     auto gbi = cfg["gbi"];
     auto gbi_floats = cfg["gbi_floats"];
     auto modding_path = opath && opath["modding"] ? opath["modding"].as<std::string>() : "modding";
-    auto output_path = this->gDestinationPath;
 
-    this->gConfig.moddingPath = this->gSourceDirectory / modding_path;
+    if (!fs::exists(this->gDestinationDirectory)) {
+        create_directories(this->gDestinationDirectory);
+    }
+    auto output_path = this->gDestinationDirectory;
+
+    this->gConfig.moddingPath = this->gDestinationDirectory / modding_path;
     switch (this->gConfig.exporterType) {
         case ExportType::Binary: {
             std::string extension = "";
@@ -1166,6 +1171,7 @@ void Companion::Process() {
     if(cfg["enums"]) {
         auto enums = GetSafeNode<std::vector<std::string>>(cfg, "enums");
         for (auto& file : enums) {
+            file = this->gSourceDirectory / file;
             this->ParseEnums(file);
         }
     }
@@ -1277,7 +1283,7 @@ void Companion::Process() {
     }
 
     // Write entries hash
-    std::ofstream file(this->gDestinationPath / "torch.hash.yml", std::ios::binary);
+    std::ofstream file(this->gDestinationDirectory / "torch.hash.yml", std::ios::binary);
     file << this->gHashNode;
     file.close();
 
@@ -1578,6 +1584,14 @@ std::string Companion::RelativePath(const std::string& path) const {
     return doutput;
 }
 
+std::string Companion::RelativePathToDestDir(const std::string& path) const {
+    return relative(path, this->gDestinationDirectory);
+}
+
+std::string Companion::RelativePathToSrcDir(const std::string& path) const {
+    return relative(path, this->gSourceDirectory);
+}
+
 std::string Companion::CalculateHash(const std::vector<uint8_t>& data) {
     return Chocobo1::SHA1().addData(data).finalize().toString();
 }
diff --git a/src/Companion.h b/src/Companion.h
index bff5a72f..b40dad36 100644
--- a/src/Companion.h
+++ b/src/Companion.h
@@ -114,7 +114,7 @@ class Companion {
 
     explicit Companion(std::filesystem::path rom, const ArchiveType otr, const bool debug, const bool modding = false,
                        const std::string& srcDir = "", const std::string& destPath = "") : gCartridge(nullptr),
-                       gSourceDirectory(srcDir), gDestinationPath(destPath) {
+                       gSourceDirectory(srcDir), gDestinationDirectory(destPath) {
         this->gRomPath = rom;
         this->gConfig.otrMode = otr;
         this->gConfig.debug = debug;
@@ -124,7 +124,7 @@ class Companion {
 
     explicit Companion(std::vector<uint8_t> rom, const ArchiveType otr, const bool debug, const bool modding = false,
                        const std::string& srcDir = "", const std::string& destPath = "") : gCartridge(nullptr),
-                       gSourceDirectory(srcDir), gDestinationPath(destPath) {
+                       gSourceDirectory(srcDir), gDestinationDirectory(destPath) {
         this->gRomData = rom;
         this->gConfig.otrMode = otr;
         this->gConfig.debug = debug;
@@ -151,6 +151,7 @@ class Companion {
     N64::Cartridge* GetCartridge() const { return this->gCartridge.get(); }
     std::vector<uint8_t>& GetRomData() { return this->gRomData; }
     std::string GetOutputPath() { return this->gConfig.outputPath; }
+    std::string GetDestRelativeOutputPath() { return RelativePathToDestDir(GetOutputPath()); }
 
     GBIVersion GetGBIVersion() const { return this->gConfig.gbi.version; }
     GBIMinorVersion GetGBIMinorVersion() const { return  this->gConfig.gbi.subversion; }
@@ -179,6 +180,8 @@ class Companion {
     static void Pack(const std::string& folder, const std::string& output, const ArchiveType otrMode);
     std::string NormalizeAsset(const std::string& name) const;
     std::string RelativePath(const std::string& path) const;
+    std::string RelativePathToSrcDir(const std::string& path) const;
+    std::string RelativePathToDestDir(const std::string& path) const;
     void RegisterCompanionFile(const std::string path, std::vector<char> data);
 
     TorchConfig& GetConfig() { return this->gConfig; }
@@ -190,7 +193,7 @@ class Companion {
     TorchConfig gConfig;
     YAML::Node gModdingConfig;
     fs::path gSourceDirectory;
-    fs::path gDestinationPath;
+    fs::path gDestinationDirectory;
     fs::path gCurrentDirectory;
     std::string gCurrentHash;
     std::string gAssetPath;
diff --git a/src/factories/CompressedTextureFactory.cpp b/src/factories/CompressedTextureFactory.cpp
index 6b507e44..34ccc61a 100644
--- a/src/factories/CompressedTextureFactory.cpp
+++ b/src/factories/CompressedTextureFactory.cpp
@@ -218,7 +218,7 @@ ExportResult CompressedTextureCodeExporter::Export(std::ostream &write, std::sha
 
         write << tab_t << "{\n";
 
-        write << tab_t << tab_t << "#include \"" << Companion::Instance->GetOutputPath() + "/" << *replacement << ".incbin.c\"\n";
+        write << tab_t << tab_t << "#include \"" << Companion::Instance->GetDestRelativeOutputPath() + "/" << *replacement << ".incbin.c\"\n";
 
         write << tab_t << "},\n";
 
@@ -231,7 +231,7 @@ ExportResult CompressedTextureCodeExporter::Export(std::ostream &write, std::sha
     } else {
         write << "u8 " << symbol  << "[] = {\n";
 
-        write << tab_t << "#include \"" << Companion::Instance->GetOutputPath() + "/" << *replacement << ".incbin.c\"\n";
+        write << tab_t << "#include \"" << Companion::Instance->GetDestRelativeOutputPath() + "/" << *replacement << ".incbin.c\"\n";
 
         write << "};\n";
 
diff --git a/src/factories/TextureFactory.cpp b/src/factories/TextureFactory.cpp
index 75b67969..8e9d53ca 100644
--- a/src/factories/TextureFactory.cpp
+++ b/src/factories/TextureFactory.cpp
@@ -137,7 +137,7 @@ ExportResult TextureCodeExporter::Export(std::ostream &write, std::shared_ptr<IP
 
         write << tab_t << "{\n";
         if (!Companion::Instance->IsUsingIndividualIncludes()){
-            write << tab_t << tab_t << "#include \"" << Companion::Instance->GetOutputPath() + "/" << *replacement << ".inc.c\"\n";
+            write << tab_t << tab_t << "#include \"" << Companion::Instance->GetDestRelativeOutputPath() + "/" << *replacement << ".inc.c\"\n";
         } else {
             write << imgstream.str();
         }
@@ -153,7 +153,7 @@ ExportResult TextureCodeExporter::Export(std::ostream &write, std::shared_ptr<IP
         write << GetSafeNode<std::string>(node, "ctype", "u8") << " " << symbol  << "[] = {\n";
 
         if (!Companion::Instance->IsUsingIndividualIncludes()){
-            write << tab_t << "#include \"" << Companion::Instance->GetOutputPath() + "/" << *replacement << ".inc.c\"\n";
+            write << tab_t << "#include \"" << Companion::Instance->GetDestRelativeOutputPath() + "/" << *replacement << ".inc.c\"\n";
         } else {
             write << imgstream.str();
         }
diff --git a/src/main.cpp b/src/main.cpp
index afb3536c..6fb356fb 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -21,18 +21,17 @@ int main(int argc, char *argv[]) {
     bool xmlMode = false;
     bool debug = false;
     std::string srcdir;
-    std::string destdir
+    std::string destdir;
 
     app.require_subcommand();
 
-    app.add_option("-s", "--srcdir", srcdir, "Set source directory to locate config.yml, asset metadata, and modding files for importing");
-    app.add_option("-d", "--destdir", destdir, "Set destination directory for exporting and generating binaries and source code");
-
     /* Generate an OTR */
     const auto otr = app.add_subcommand("otr", "OTR - Generates an otr\n");
 
     otr->add_option("<baserom.z64>", filename, "")->required()->check(CLI::ExistingFile);
     otr->add_flag("-v,--verbose", debug, "Verbose Debug Mode");
+    otr->add_option("-s,--srcdir", srcdir, "Set source directory to locate config.yml and asset metadata for processing")->check(CLI::ExistingDirectory);
+    otr->add_option("-d,--destdir", destdir, "Set destination directory for export");
 
     otr->parse_complete_callback([&] {
         const auto instance = Companion::Instance = new Companion(filename, ArchiveType::OTR, debug, srcdir, destdir);
@@ -44,6 +43,8 @@ int main(int argc, char *argv[]) {
 
     o2r->add_option("<baserom.z64>", filename, "")->required()->check(CLI::ExistingFile);
     o2r->add_flag("-v,--verbose", debug, "Verbose Debug Mode");
+    o2r->add_option("-s,--srcdir", srcdir, "Set source directory to locate config.yml and asset metadata for processing")->check(CLI::ExistingDirectory);
+    o2r->add_option("-d,--destdir", destdir, "Set destination directory for export");
 
     o2r->parse_complete_callback([&] {
         const auto instance = Companion::Instance = new Companion(filename, ArchiveType::O2R, debug, srcdir, destdir);
@@ -55,6 +56,8 @@ int main(int argc, char *argv[]) {
 
     code->add_option("<baserom.z64>", filename, "")->required()->check(CLI::ExistingFile);
     code->add_flag("-v,--verbose", debug, "Verbose Debug Mode; adds offsets to C code");
+    code->add_option("-s,--srcdir", srcdir, "Set source directory to locate config.yml and asset metadata for processing")->check(CLI::ExistingDirectory);
+    code->add_option("-d,--destdir", destdir, "Set destination directory to place C code to");
 
     code->parse_complete_callback([&]() {
         const auto instance = Companion::Instance = new Companion(filename, ArchiveType::None, debug, srcdir, destdir);
@@ -65,6 +68,8 @@ int main(int argc, char *argv[]) {
     const auto binary = app.add_subcommand("binary", "Binary - Generates a binary\n");
 
     binary->add_option("<baserom.z64>", filename, "")->required()->check(CLI::ExistingFile);
+    binary->add_option("-s,--srcdir", srcdir, "Set source directory to locate config.yml and asset metadata for processing")->check(CLI::ExistingDirectory);
+    binary->add_option("-d,--destdir", destdir, "Set destination directory to place binary to");
 
     binary->parse_complete_callback([&] {
         const auto instance = Companion::Instance = new Companion(filename, ArchiveType::None, debug, srcdir, destdir);
@@ -76,7 +81,8 @@ int main(int argc, char *argv[]) {
 
     header->add_option("<baserom.z64>", filename, "")->required()->check(CLI::ExistingFile);
     header->add_flag("-o,--otr", otrModeSelected, "OTR/O2R Mode");
-
+    header->add_option("-s,--srcdir", srcdir, "Set source directory to locate config.yml and asset metadata for processing")->check(CLI::ExistingDirectory);
+    header->add_option("-d,--destdir", destdir, "Set destination directory to place headers to");
 
     header->parse_complete_callback([&] {
         if (otrModeSelected) {
@@ -121,6 +127,8 @@ int main(int argc, char *argv[]) {
     modding_import->add_option("mode", mode, "code, otr, o2r or header")->required();
     modding_import->add_option("<baserom.z64>", filename, "")->required()->check(CLI::ExistingFile);
     modding_import->add_flag("-v,--verbose", debug, "Verbose Debug Mode");
+    modding_import->add_option("-s,--srcdir", srcdir, "Set source directory to locate config.yml and asset metadata for processing, including modified files")->check(CLI::ExistingDirectory);
+    modding_import->add_option("-d,--destdir", destdir, "Set destination directory to place for generating C code");
 
     modding_import->parse_complete_callback([&] {
         ArchiveType otrMode;
@@ -147,6 +155,8 @@ int main(int argc, char *argv[]) {
 
     modding_export->add_flag("-x,--xml", xmlMode, "XML Mode");
     modding_export->add_option("<baserom.z64>", filename, "")->required()->check(CLI::ExistingFile);
+    modding_export->add_option("-s,--srcdir", srcdir, "Set source directory to locate config.yml and asset metadata for processing, including modified files")->check(CLI::ExistingDirectory);
+    modding_export->add_option("-d,--destdir", destdir, "Set destination directory to place for generating modified files");
 
     modding_export->parse_complete_callback([&] {
         const auto instance = Companion::Instance = new Companion(filename, ArchiveType::None, debug, srcdir, destdir);
